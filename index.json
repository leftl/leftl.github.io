[{"content":"Open-source projects are plentiful, so I decided to highlight a few standouts which deserve some extra love. Well\u0026hellip; all of them deserve extra love, but I\u0026rsquo;d like to highlight a few of my (100% biased) favorites. First up is a self-hosted media server I\u0026rsquo;ve had the pleasure of using for several years, now \u0026ndash; Jellyfin.\nWhat is Jellyfin Jellyfin allows you to host the TV Series/Films/Music you own on a single server, and access this media from any device either through a web browser or client. It is essentially your own personal Netflix, handling some technical details behind the scenes (like automatically fetching metadata and ensuring media is compatible with all clients) so you can focus on just enjoying your media.\nThis project is based on Emby, forked from the last open-source release after Emby decided to change their licensing and go closed-source. The goal of Jellyfin is to provide the premier open-source media server experience, similar to Emby and Plex, but without requiring a paid license to access all features.\nRunning Jellyfin Depending on the hardware you wish to run Jellyfin on, the installation process will be different. Luckily, there is a guide available that can quickly get you going. If you prefer to follow along with a video, there are many tutorials available on YouTube, as well.\n Official Quick Start Guide  How to Contribute The greatest part of open source software is that you have the freedom to implement the features you want to see in the final product. Of course, not everyone is a developer, but anyone can contribute! From suggesting new features and reporting bugs, to creating art and translating the interface, everyone is free to contribute to the project! All source code is available on GitHub:\n Server - jellyfin/jellyfin Web Client (Official) - jellyfin/jellyfin-web Android TV - jellyfin/jellyfin-androidtv iOS/tvOS (Official) - jellyfin/Swiftfin  Additionally, you can read the contributors guide to get started. If you have never contributed to a project before, the Jellyfin team would love to help you with your first pull request (PR). Most of the official repos feature a good first issue label to help you get started with your first contribution. The team helped me with my first PR, and I can promise your time/effort will be appreciated, no matter how simple you believe your contribution maybe!\n","permalink":"https://twtrs.com/2021/10/open-source-highlight-jellyfin/","summary":"Open-source projects are plentiful, so I decided to highlight a few standouts which deserve some extra love. Well\u0026hellip; all of them deserve extra love, but I\u0026rsquo;d like to highlight a few of my (100% biased) favorites. First up is a self-hosted media server I\u0026rsquo;ve had the pleasure of using for several years, now \u0026ndash; Jellyfin.\nWhat is Jellyfin Jellyfin allows you to host the TV Series/Films/Music you own on a single server, and access this media from any device either through a web browser or client.","title":"Open-Source Highlight: Jellyfin"},{"content":"If you\u0026rsquo;re already developing a C/C++ project in VS Code, configuring the built-in debugger will allow you to fully use features already within the IDE with only a single configuration file. To those are used to debugging in IDEs like IntelliJ or Visual Studio, this is a much more familiar and pleasant experience. Additionally, this can be done both locally and over SSH via the Remote - SSH extension.\nFor Computer Science \u0026amp; Engineering courses at the UW, I typically open the folder containing my entire repo in VS Code (i.e. ~/code/cse3xx-21au-username), which contains all of the course\u0026rsquo;s projects. This makes configuring debugging easier since you don\u0026rsquo;t have to copy this JSON file into every folder if you typically just open a project\u0026rsquo;s folder directly (i.e. ~/code/cse3xx-21au-username/hw1 ), as the configuration is expected to be found in a folder at the highest level with the current workspace.\nConfiguring Visual Debugging To open the default configuration file, click the Run and Debug icon (or Ctrl+Shift+d), then click the cog icon at the top of the sidebar that opens. A file titled launch.json should be created and opened.\nHere\u0026rsquo;s an example debugging configuration for an executable called test_suite in a CentOS 8 based environment (as used in the course CSE 333):\nSimple launch.json Example { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Run \u0026amp; Debug test_suite\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}/test_suite\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/opt/rh/gcc-toolset-9/root/usr/bin/gdb\u0026#34; } ] } Save this file, and if everything is configured correctly, you should be ready to debug.\nDebugging is now as easy as clicking the Run and Debug icon (or Ctrl+Shift+d), selecting the configuration named Run \u0026amp; Debug test_suite in the dropdown box that appears at the top of the sidebar, then pressing the Play/Run button (or F5).\nImportant note: this setup requires that you have a file open in the correct hw folder before running the debugger. This configuration depends on the path of that open file to find the path of the test_suite executable. For example, if you want to debug the executable test_suite in a folder named hw1, you would simply have open a file within the directory containing that executable, such as ~/cse3xx-21au-username/hw1/LinkedList.c, before starting a debugging session.\nCreating breakpoints and adding a variable to the watchlist is similar other IDEs (see more: https://code.visualstudio.com/Docs/editor/debugging).\nYou can add more configs to target different executables, and edit the args field to append arguments just like you would on the command line. Here\u0026rsquo;s another launch.json configuration that runs only a specific set of test cases from the test_suite, and adds another configuration to debug an executable named server:\nExample launch.json with Multiple Configurations { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Run \u0026amp; Debug test_suite\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}/test_suite\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;--gtest_filter=Test_SomeTestCase.*\u0026#34; \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/opt/rh/gcc-toolset-9/root/usr/bin/gdb\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Run \u0026amp; Debug server\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}/server\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/opt/rh/gcc-toolset-9/root/usr/bin/gdb\u0026#34; } ] } Additional Resources Overview on Microsoft\u0026rsquo;s website: https://code.visualstudio.com/docs/cpp/config-linux#_debug-helloworldcpp\n","permalink":"https://twtrs.com/2021/10/visual-debugging-on-vs-code-using-gdb/","summary":"If you\u0026rsquo;re already developing a C/C++ project in VS Code, configuring the built-in debugger will allow you to fully use features already within the IDE with only a single configuration file. To those are used to debugging in IDEs like IntelliJ or Visual Studio, this is a much more familiar and pleasant experience. Additionally, this can be done both locally and over SSH via the Remote - SSH extension.\nFor Computer Science \u0026amp; Engineering courses at the UW, I typically open the folder containing my entire repo in VS Code (i.","title":"Visual Debugging on VS Code Using GDB"}]