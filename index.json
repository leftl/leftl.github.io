[{"content":"For the second entry in the LeetCode series, I will be discussing another medium-difficulty problem. However, unlike the in-depth analysis covered in the last LeetCode problem, this post will be a succinct overview of an efficient solution. This problem is great because it\u0026rsquo;s easily to visualize the input, and it does not have a lot of constraints. It also never hurts to have more practice with multidimensional arrays + graph searching algorithms.\nThe Problem The problem, Number of Islands - LeetCode is as follows:\n Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nConstraints:\n m == grid.length n == grid[i].length 1 \u0026lt;= m, n \u0026lt;= 300 grid[i][j] is '0' or '1'.   Example Input: grid = [['1', '1', '1', '1'], ['1', '1', '0', '0'], ['0', '0', '1', '1'], ['1', '0', '0', '0']] Output: 3 Approach The approach leverages recursion and uses depth-first search (DFS) to discover all elements composing a single island. Then, we must simply count each island that is fully discovered.\n First, find an island. If no island is found, the expected output is 0. Upon the first piece of land found (i.e. an element is '1'), discover the rest of the island. Using recursion \u0026amp; DFS, we can explore all adjacent nodes and their neighbors, overwriting all elements indicating land with '0', marking it as explored. After the DFS has been completed, marking the entirety of one island as explored, increment a counter. Repeat this process for all elements in the input, grid. Return the value of the counter.  class Solution { public: int dx[4] = {0, 0, -1, 1}; // adjacencies (x-axis)  int dy[4] = {-1, 1, 0, 0}; // adjacencies (y-axis)  int m, n; int numIslands(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid) { m = grid.size(); n = grid[0].size(); int numIslands = 0; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (grid[i][j] == \u0026#39;1\u0026#39;) { exploreIsland(grid, i, j); numIslands++; } } } return numIslands; } // DFS search for immediately neighboring land.  void exploreIsland(vector\u0026lt;vector\u0026lt;char\u0026gt;\u0026gt;\u0026amp; grid, int i, int j) { if (i \u0026lt; 0 || i \u0026gt;= m || j \u0026lt; 0 || j \u0026gt;= n) { return; } if (grid[i][j] == \u0026#39;0\u0026#39;) { return; } grid[i][j] = \u0026#39;0\u0026#39;; for (int k = 0; k \u0026lt; 4; k++){ exploreIsland(grid, i + dy[k], j + dx[k]); } } }; It\u0026rsquo;s worth noting that since the input is passed by reference, the modifications to the input will modify the data in the caller\u0026rsquo;s scope. However, since there is no restriction against this, we can save time \u0026amp; space by not creating a copy of the grid and instead directly modify the input.\nRun-time Note that through the nested loops in the numIslands function, we will visit each element once (input size is m * n) to find the land of an island. However, during the DFS search in destroyIslands, we may visit elements that have not yet been visited by the outer loops. That means each node may be visited twice in the worst case, so we see a run-time of:\n\\[O(m * n)\\]\n","permalink":"https://twtrs.com/2021/11/leetcode-number-of-islands/","summary":"For the second entry in the LeetCode series, I will be discussing another medium-difficulty problem. However, unlike the in-depth analysis covered in the last LeetCode problem, this post will be a succinct overview of an efficient solution. This problem is great because it\u0026rsquo;s easily to visualize the input, and it does not have a lot of constraints. It also never hurts to have more practice with multidimensional arrays + graph searching algorithms.","title":"LeetCode: Number of Islands"},{"content":"Obsibian: Smart Plaintext Notes Obsidian is a modern cross-platform note-taking application. By adapting my note-taking habits to fit the strengths of Obsidian, my notes have become more meaningful in content and reviewability. Those familiar with Notion and similar note-taking applications will feel right at home, but what makes Obsidian different?\nFeatures: Backlinking  The star of the show: linking notes to build connections. It sounds pretty inconsequential, but it is great for helping structure your notes in more meaningful ways improving the value of your notes. Forming connections between notes also makes reviewing/studying notes much easier. By focusing on ideas as the topic of a single note instead of Lecture XX - Jan 01, the notes truly become yours. You can easily reorder, and expand or split notes to form new connections to cement your understanding. The syntax is as simple as [[Title of Note to Link]], and you even get a cool graph:   Local first  You own your data by default. Syncing can be easily done through various 3rd party hosting platforms such as OneDrive, Dropbox, Google Drive—or through a premium Obsidian subscription. Even if Obsidian disappears from the face of the earth, your notes are safe on your local drive and can easily be migrated to another service. Please follow standard backup practices.  Plaintext  Markdown means your notes are stored in plaintext, readable anywhere, and can even be tracked by version control, such as git + GitHub. LaTeX support and basic syntax highlighting is built-in. A more user-friendly WYSIWYG editor (live preview) is currently being developed, for those who don\u0026rsquo;t know or particularly enjoy writing exclusively in markdown.  Plugin Ecosystem   Unlike other note-taking platforms, Obsidian has a rich community plugin ecosystem.\n  Plugins can do anything from implementing new functionality to modifying the user interface. Nothing is off the table.\n  Some of my favorite plugins:\n Calendar: a simple calendar view that links to daily, weekly, and monthly notes. Great for quick notes and journaling. Kanban: a kanban scheduling/task-board Advanced Tables: makes tables in markdown more pleasant to create and modify.    Conclusion If you take notes digitally, this application is a must-have. The longer you use it, the greater the return is. Best of all, you never have to worry about lock-in since your notes will always be available in the most basic form: plaintext. It\u0026rsquo;s free to try, and if you end up enjoying it as much as I have, consider supporting development .\n","permalink":"https://twtrs.com/2021/11/obsibian-smart-plaintext-notes/","summary":"Obsibian: Smart Plaintext Notes Obsidian is a modern cross-platform note-taking application. By adapting my note-taking habits to fit the strengths of Obsidian, my notes have become more meaningful in content and reviewability. Those familiar with Notion and similar note-taking applications will feel right at home, but what makes Obsidian different?\nFeatures: Backlinking  The star of the show: linking notes to build connections. It sounds pretty inconsequential, but it is great for helping structure your notes in more meaningful ways improving the value of your notes.","title":"Obsibian: Smart Plaintext Notes"},{"content":"Continuing where we left off last week, let\u0026rsquo;s finally dicuss the optimal solution to the Set Matrix Zeroes problem from LeetCode. If you have not read Part 1, please do so! In the previous post, we discussed the problem \u0026amp; constraints, as well as some intuition behind the solution. Building off of this intuition, let\u0026rsquo;s go over the algorithm!\nThe Solution Recalling our constant-space requirement, and the conflicts that can come from writing zeroes before completing the first read, how can we safely indicate which rows and columns will be set to zero without compromising correctness? As hinted in the last post, we can store flags within in the input matrix itself! Specifically, in the 0\u0026lsquo;th column and 0\u0026lsquo;th row.\nTo set these flags, we must simply iterate through the matrix, and for every zero that is encountered, write zero as a flag in the 0 position of the corresponding column and row. That is, if we find a zero at some index, (i, j), we will write a zero at matrix[i][0] and matrix[0][j]. The image below shows these flags written on an input. We expect this to be safe since, per the set-zeroes rule, this element will be zero in the final solution! But is it really safe? Let\u0026rsquo;s find out as we write the zeroes.\nNow that we know where zeroes need to be filled, all that is left is to fill zeroes for each zero flag found in the 0\u0026lsquo;th (i.e. first by index value) column and row. That is, if we iterate through the matrix, and for some element (i,j) find a zero flag at matrix[i][0] or matrix[0][j], write a zero at that element. However, similar to the issue discussed last week, it is possible to overwrite these flags and have an incorrect matrix as a result. To preserve these flags, we will simply write to the row and column containint the flags last! One elegant way to do this is to traverse the matrix backward. However, consider the following matrix and as zeroes are being filled:\nLooking at the element shaded red, at position (0,2), a zero has been incorrectly placed. There is no zero in the corresponding row or column defining this element. What went wrong? Since there was a zero in the first row, specifically at (1,0), when we set the flag in this column, it\u0026rsquo;s written at (0,0). This seems fine until we iterate through the first row. The flag at the (0,0) position pertains only to the column, not the row. So, as zeroes are filled, the flag incorrectly indicates that the first row must also be overwritten with zeroes. This is incorrect. But how can we fix it?\nInstead of writing a flag in the matrix if the 0\u0026lsquo;th column must be overwritten, a single boolean can be used. That is, we will not write a zero at (0,0), but instead set a bool col_fill = true. As a result, we will check this bool value when setting zeroes for the column, rather than the element (0,0). That element can now be used safely as a flag for just the 0\u0026lsquo;th row.\nAnd that\u0026rsquo;s it. If you\u0026rsquo;ve followed along this far, congratulations! You now have all of the pieces needed to write the algorithm meeting the constraints given.\nAlgorithm (C++) class Solution { public: void setZeroes(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; \u0026amp;matrix) { bool col_fill = false; // if a zero is found, write a zero to the first element in the  // corresponding row and column. A zero will act as a flag indicating  // where zeroes will be filled.  for (int i = 0; i \u0026lt; matrix.size(); i++) { // case: first column holding flags will be overwritten  if (!col_fill \u0026amp;\u0026amp; matrix[i][0] == 0) { col_fill = true; } for (int j = 1; j \u0026lt; matrix[0].size(); j++) { if (matrix[i][j] == 0) { matrix[0][j] = 0; matrix[i][0] = 0; } } } // Fill the zeroes the zeroes in place.  // Handle case where the first colum will be over written,  // traversing the matrix backwards to preserve flags in first row.  for (int i = matrix.size() - 1; i \u0026gt; -1; i--) { for (int j = matrix[0].size() - 1; j \u0026gt; 0; j--) { if (matrix[0][j] == 0 || matrix[i][0] == 0) { matrix[i][j] = 0; } } if (col_fill) { matrix[i][0] = 0; } } } }; Run-time \u0026amp; Correctness Since we have to read all of the elements at least once to discover which elements are zero, we can have no fewer than m * n operations. Note that only two traversals of the matrix were required for this solution: one to read the zeroes and one to write the zeroes. Therefore, the run-time is O(m * n).\nAdditionally, since we only declare a single variable in the algorithm, it must be the case that the space complexity is constant, i.e. O(1).\nSuppose an element is zero at some index (i,j) on a matrix M, but the algorithm does not correctly fill zeroes on the corresponding row and column. That is, there was a flag set to zero on M[i][0] or M[0][j] (or col_fill was true if j = 0), but some zero was not filled based on this flag. We note that each flag corresponds to either one row or one column, after resolving the conflict of the flag found at the index (0,0), as shown above. The value of these flags will be zero if and only if it\u0026rsquo;s zero in the input or by the set-zeroes rule, and will be set for every zero found in the input. However, since every element in the input checks both flags when settings zeroes, it must be the case all elements on the i\u0026lsquo;th column and j\u0026lsquo;th row are zero. Therefore, by contradiction, the algorithm must be correct.\nConclusion My experience with both finding the optimal solution and completing this write-up has reminded me that algorithms are difficult to create. It\u0026rsquo;s okay if you don\u0026rsquo;t find a similar solution on your first try (or even a working solution at all), I surely didn\u0026rsquo;t. Like most things in life, problem-solving takes practice, and that\u0026rsquo;s exactly why platforms like HackerRank and LeetCode exist. Working through this solution has shown me not only how far I\u0026rsquo;ve come since my first year as a CS undergrad, but how much more I still have to learn. Feel free to reach out with any suggestions and/or corrections via the contacts on the landing page. Thanks for reading!\n","permalink":"https://twtrs.com/2021/11/leetcode-set-matrix-zeroes-part-2/","summary":"Continuing where we left off last week, let\u0026rsquo;s finally dicuss the optimal solution to the Set Matrix Zeroes problem from LeetCode. If you have not read Part 1, please do so! In the previous post, we discussed the problem \u0026amp; constraints, as well as some intuition behind the solution. Building off of this intuition, let\u0026rsquo;s go over the algorithm!\nThe Solution Recalling our constant-space requirement, and the conflicts that can come from writing zeroes before completing the first read, how can we safely indicate which rows and columns will be set to zero without compromising correctness?","title":"Leetcode: Set Matrix Zeroes (Part 2)"},{"content":"This problem, of medium difficulty, sounds trivial at first glance. However, given the constraints, it\u0026rsquo;s not as straightforward as it initially appears.\nThe Problem The problems is set-up as seen here: Set Matrix Zeroes - LeetCode\n Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0\u0026rsquo;s, and return the matrix.\nYou must do it in place.\nConstraints:\n m == matrix.length n == matrix[0].length 1 \u0026lt;= m, n \u0026lt;= 200 2^31 \u0026lt;= matrix[i][j] \u0026lt;= 2^31 - 1   We will be discussing the optimal solution, which has an additional constraint: space must be O(1), also known as constant-space. This means we cannot create a copy of the matrix or use any other data structures which depend on m and/or n (e.g. arrays, lists, maps).\nThe following image depicts the expected output of the algorithm, following the order input -\u0026gt; output. We can see the only 0 in the input on the input is in the intersection of the third row from the top (index: 2) and the 2nd column from the left (index: 1). We will represent this position as the tuple, (2,1).\nBy the constraints given, we can note the input cannot be empty (furthermore, it must be at least 1 x 0. That is, one row and zero columns, per a row-major representation). We can also see that each element in the matrix is a typical signed 4-byte integer. While there is no constraint on the run-time of this algorithm, it is given that the algorithm must modify the matrix in place. Additionally, with the constant-space requirement, we cannot make a copy of the matrix to preserve all values in the original matrix.\nConsiderations The fact that we modify the only \u0026ldquo;source of truth,\u0026rdquo; means we must tread carefully as we build output. Your first intuition may be to simply traverse the matrix, and set columns and rows to zero as a 0 element is encountered. However, if we modify the input before finding all positions, we may read a \u0026ldquo;new\u0026rdquo; 0 element which is a 1 in the input. We will illustrate this concern in the diagram below:\nIf we modify the matrix during the first iteration, it is possible to modify elements not yet visited. In the matrix labeled C, the next element at (0,1) is now 0, per applying the set-zero rule on the index (0,0). However, the algorithm will now apply the set-zeros rule to the index (0,1) as seen in matrix D. Recall from the input, A, that there was no 0 element on the second column or the second row. The resulting matrix is not correct, even though the expected output is the intermediary matrix, B.\nIntuition To avoid the issue described above, we must complete the first read before modifying the input. This requires creating some record(s) of the rows and columns to be overwritten with zeros. However, keeping in mind the constant-space requirement, this record must be contained inside the matrix itself and/or some constant number of variables (i.e. not bound by m or n). No additional data structures can be created.\nSome hints to help reach the solution:\n Is there a particular row/column which can be used to hold flags? Does this selection vary depending on if you iterate through the matrix by rows or columns? Are there special cases to applying the set-zero rule to this row/column holding the flags?  Wrapping-Up In part two we will complete the intuition, go over the algorithm (in C++), and discuss overall run-time/correctness. Try to build on some of the intuition shared in this post and find a solution of your own. Otherwise, catch the solution next week!\n","permalink":"https://twtrs.com/2021/11/leetcode-set-matrix-zeroes-part-1/","summary":"This problem, of medium difficulty, sounds trivial at first glance. However, given the constraints, it\u0026rsquo;s not as straightforward as it initially appears.\nThe Problem The problems is set-up as seen here: Set Matrix Zeroes - LeetCode\n Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0\u0026rsquo;s, and return the matrix.\nYou must do it in place.\nConstraints:\n m == matrix.","title":"Leetcode: Set Matrix Zeroes (Part 1)"},{"content":"Open-source projects are plentiful, so I decided to highlight a few standouts which deserve some extra love. Well\u0026hellip; all of them deserve extra love, but I\u0026rsquo;d like to highlight a few of my (100% biased) favorites. First up is a self-hosted media server I\u0026rsquo;ve had the pleasure of using for several years, now \u0026ndash; Jellyfin.\nWhat is Jellyfin Jellyfin allows you to host the TV Series/Films/Music you own on a single server, and access this media from any device either through a web browser or client. It is essentially your own personal Netflix, handling some technical details behind the scenes (like automatically fetching metadata and ensuring media is compatible with all clients) so you can focus on just enjoying your media.\nThis project is based on Emby, forked from the last open-source release after Emby decided to change their licensing and go closed-source. The goal of Jellyfin is to provide the premier open-source media server experience, similar to Emby and Plex, but without requiring a paid license to access all features.\nRunning Jellyfin Depending on the hardware you wish to run Jellyfin on, the installation process will be different. Luckily, there is a guide available that can quickly get you going. If you prefer to follow along with a video, there are many tutorials available on YouTube, as well.\n Official Quick Start Guide  How to Contribute The greatest part of open source software is that you have the freedom to implement the features you want to see in the final product. Of course, not everyone is a developer, but anyone can contribute! From suggesting new features and reporting bugs, to creating art and translating the interface, everyone is free to contribute to the project! All source code is available on GitHub:\n Server - jellyfin/jellyfin Web Client (Official) - jellyfin/jellyfin-web Android TV - jellyfin/jellyfin-androidtv iOS/tvOS (Official) - jellyfin/Swiftfin  Additionally, you can read the contributors guide to get started. If you have never contributed to a project before, the Jellyfin team would love to help you with your first pull request (PR). Most of the official repos feature a good first issue label to help you get started with your first contribution. The team helped me with my first PR, and I can promise your time/effort will be appreciated, no matter how simple you believe your contribution maybe!\n","permalink":"https://twtrs.com/2021/10/open-source-highlight-jellyfin/","summary":"Open-source projects are plentiful, so I decided to highlight a few standouts which deserve some extra love. Well\u0026hellip; all of them deserve extra love, but I\u0026rsquo;d like to highlight a few of my (100% biased) favorites. First up is a self-hosted media server I\u0026rsquo;ve had the pleasure of using for several years, now \u0026ndash; Jellyfin.\nWhat is Jellyfin Jellyfin allows you to host the TV Series/Films/Music you own on a single server, and access this media from any device either through a web browser or client.","title":"Open-Source Highlight: Jellyfin"},{"content":"If you\u0026rsquo;re already developing a C/C++ project in VS Code, configuring the built-in debugger will allow you to fully use features already within the IDE with only a single configuration file. To those are used to debugging in IDEs like IntelliJ or Visual Studio, this is a much more familiar and pleasant experience. Additionally, this can be done both locally and over SSH via the Remote - SSH extension.\nFor Computer Science \u0026amp; Engineering courses at the UW, I typically open the folder containing my entire repo in VS Code (i.e. ~/code/cse3xx-21au-username), which contains all of the course\u0026rsquo;s projects. This makes configuring debugging easier since you don\u0026rsquo;t have to copy this JSON file into every folder if you typically just open a project\u0026rsquo;s folder directly (i.e. ~/code/cse3xx-21au-username/hw1 ), as the configuration is expected to be found in a folder at the highest level with the current workspace.\nConfiguring Visual Debugging To open the default configuration file, click the Run and Debug icon (or Ctrl+Shift+d), then click the cog icon at the top of the sidebar that opens. A file titled launch.json should be created and opened.\nHere\u0026rsquo;s an example debugging configuration for an executable called test_suite in a CentOS 8 based environment (as used in the course CSE 333):\nSimple launch.json Example { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Run \u0026amp; Debug test_suite\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}/test_suite\u0026#34;, \u0026#34;args\u0026#34;: [], \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/opt/rh/gcc-toolset-9/root/usr/bin/gdb\u0026#34; } ] } Save this file, and if everything is configured correctly, you should be ready to debug.\nDebugging is now as easy as clicking the Run and Debug icon (or Ctrl+Shift+d), selecting the configuration named Run \u0026amp; Debug test_suite in the dropdown box that appears at the top of the sidebar, then pressing the Play/Run button (or F5).\nImportant note: this setup requires that you have a file open in the correct hw folder before running the debugger. This configuration depends on the path of that open file to find the path of the test_suite executable. For example, if you want to debug the executable test_suite in a folder named hw1, you would simply have open a file within the directory containing that executable, such as ~/cse3xx-21au-username/hw1/LinkedList.c, before starting a debugging session.\nCreating breakpoints and adding a variable to the watchlist is similar other IDEs (see more: https://code.visualstudio.com/Docs/editor/debugging).\nYou can add more configs to target different executables, and edit the args field to append arguments just like you would on the command line. Here\u0026rsquo;s another launch.json configuration that runs only a specific set of test cases from the test_suite, and adds another configuration to debug an executable named server:\nExample launch.json with Multiple Configurations { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Run \u0026amp; Debug test_suite\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}/test_suite\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;--gtest_filter=Test_SomeTestCase.*\u0026#34; \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/opt/rh/gcc-toolset-9/root/usr/bin/gdb\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;Run \u0026amp; Debug server\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;cppdbg\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${fileDirname}/server\u0026#34;, \u0026#34;stopAtEntry\u0026#34;: false, \u0026#34;cwd\u0026#34;: \u0026#34;${fileDirname}\u0026#34;, \u0026#34;environment\u0026#34;: [], \u0026#34;externalConsole\u0026#34;: false, \u0026#34;MIMode\u0026#34;: \u0026#34;gdb\u0026#34;, \u0026#34;setupCommands\u0026#34;: [ { \u0026#34;description\u0026#34;: \u0026#34;Enable pretty-printing for gdb\u0026#34;, \u0026#34;text\u0026#34;: \u0026#34;-enable-pretty-printing\u0026#34;, \u0026#34;ignoreFailures\u0026#34;: true } ], \u0026#34;preLaunchTask\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;miDebuggerPath\u0026#34;: \u0026#34;/opt/rh/gcc-toolset-9/root/usr/bin/gdb\u0026#34; } ] } Additional Resources Overview on Microsoft\u0026rsquo;s website: https://code.visualstudio.com/docs/cpp/config-linux#_debug-helloworldcpp\n","permalink":"https://twtrs.com/2021/10/visual-debugging-on-vs-code-using-gdb/","summary":"If you\u0026rsquo;re already developing a C/C++ project in VS Code, configuring the built-in debugger will allow you to fully use features already within the IDE with only a single configuration file. To those are used to debugging in IDEs like IntelliJ or Visual Studio, this is a much more familiar and pleasant experience. Additionally, this can be done both locally and over SSH via the Remote - SSH extension.\nFor Computer Science \u0026amp; Engineering courses at the UW, I typically open the folder containing my entire repo in VS Code (i.","title":"Visual Debugging on VS Code Using GDB"}]